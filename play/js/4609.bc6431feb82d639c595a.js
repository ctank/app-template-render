"use strict";(self.webpackChunkapp_template_builder=self.webpackChunkapp_template_builder||[]).push([[4609],{7990:function(e,t,n){n.d(t,{Lv:function(){return g},Nr:function(){return d},Xp:function(){return c},nD:function(){return _}});var i=n(8964),s=n(50038),r=n(41913),f=n(57976),h=n(58461);const l=65535;function u(e){let t;return t=e[e.length-1]<65536?new Uint16Array(e.length):new Uint32Array(e.length),t.set(e,0),t}class o{constructor(e,t,n,i,s){this.lineStarts=e,this.cr=t,this.lf=n,this.crlf=i,this.isBasicASCII=s}}function c(e,t=!0){const n=[0];let i=1;for(let t=0,s=e.length;t<s;t++){const r=e.charCodeAt(t);13===r?t+1<s&&10===e.charCodeAt(t+1)?(n[i++]=t+2,t++):n[i++]=t+1:10===r&&(n[i++]=t+1)}return t?u(n):n}function d(e,t){e.length=0,e[0]=0;let n=1,i=0,s=0,r=0,f=!0;for(let h=0,l=t.length;h<l;h++){const u=t.charCodeAt(h);13===u?h+1<l&&10===t.charCodeAt(h+1)?(r++,e[n++]=h+2,h++):(i++,e[n++]=h+1):10===u?(s++,e[n++]=h+1):f&&9!==u&&(u<32||u>126)&&(f=!1)}const h=new o(u(e),i,s,r,f);return e.length=0,h}class a{constructor(e,t,n,i,s){this.bufferIndex=e,this.start=t,this.end=n,this.lineFeedCnt=i,this.length=s}}class g{constructor(e,t){this.buffer=e,this.lineStarts=t}}class b{constructor(e,t){this._pieces=[],this._tree=e,this._BOM=t,this._index=0,e.root!==f.Nc&&e.iterate(e.root,(e=>(e!==f.Nc&&this._pieces.push(e.piece),!0)))}read(){return 0===this._pieces.length?0===this._index?(this._index++,this._BOM):null:this._index>this._pieces.length-1?null:0===this._index?this._BOM+this._tree.getPieceContent(this._pieces[this._index++]):this._tree.getPieceContent(this._pieces[this._index++])}}class p{constructor(e){this._limit=e,this._cache=[]}get(e){for(let t=this._cache.length-1;t>=0;t--){const n=this._cache[t];if(n.nodeStartOffset<=e&&n.nodeStartOffset+n.node.piece.length>=e)return n}return null}get2(e){for(let t=this._cache.length-1;t>=0;t--){const n=this._cache[t];if(n.nodeStartLineNumber&&n.nodeStartLineNumber<e&&n.nodeStartLineNumber+n.node.piece.lineFeedCnt>=e)return n}return null}set(e){this._cache.length>=this._limit&&this._cache.shift(),this._cache.push(e)}validate(e){let t=!1;const n=this._cache;for(let i=0;i<n.length;i++){const s=n[i];(null===s.node.parent||s.nodeStartOffset>=e)&&(n[i]=null,t=!0)}if(t){const e=[];for(const t of n)null!==t&&e.push(t);this._cache=e}}}class _{constructor(e,t,n){this.create(e,t,n)}create(e,t,n){this._buffers=[new g("",[0])],this._lastChangeBufferPos={line:0,column:0},this.root=f.Nc,this._lineCnt=1,this._length=0,this._EOL=t,this._EOLLength=t.length,this._EOLNormalized=n;let i=null;for(let t=0,n=e.length;t<n;t++)if(e[t].buffer.length>0){e[t].lineStarts||(e[t].lineStarts=c(e[t].buffer));const n=new a(t+1,{line:0,column:0},{line:e[t].lineStarts.length-1,column:e[t].buffer.length-e[t].lineStarts[e[t].lineStarts.length-1]},e[t].lineStarts.length-1,e[t].buffer.length);this._buffers.push(e[t]),i=this.rbInsertRight(i,n)}this._searchCache=new p(1),this._lastVisitedLine={lineNumber:0,value:""},this.computeBufferMetadata()}normalizeEOL(e){const t=65535-Math.floor(21845),n=2*t;let i="",s=0;const r=[];if(this.iterate(this.root,(f=>{const h=this.getNodeContent(f),l=h.length;if(s<=t||s+l<n)return i+=h,s+=l,!0;const u=i.replace(/\r\n|\r|\n/g,e);return r.push(new g(u,c(u))),i=h,s=l,!0})),s>0){const t=i.replace(/\r\n|\r|\n/g,e);r.push(new g(t,c(t)))}this.create(r,e,!0)}getEOL(){return this._EOL}setEOL(e){this._EOL=e,this._EOLLength=this._EOL.length,this.normalizeEOL(e)}createSnapshot(e){return new b(this,e)}getOffsetAt(e,t){let n=0,i=this.root;for(;i!==f.Nc;)if(i.left!==f.Nc&&i.lf_left+1>=e)i=i.left;else{if(i.lf_left+i.piece.lineFeedCnt+1>=e){n+=i.size_left;return n+(this.getAccumulatedValue(i,e-i.lf_left-2)+t-1)}e-=i.lf_left+i.piece.lineFeedCnt,n+=i.size_left+i.piece.length,i=i.right}return n}getPositionAt(e){e=Math.floor(e),e=Math.max(0,e);let t=this.root,n=0;const s=e;for(;t!==f.Nc;)if(0!==t.size_left&&t.size_left>=e)t=t.left;else{if(t.size_left+t.piece.length>=e){const r=this.getIndexOf(t,e-t.size_left);if(n+=t.lf_left+r.index,0===r.index){const e=s-this.getOffsetAt(n+1,1);return new i.L(n+1,e+1)}return new i.L(n+1,r.remainder+1)}if(e-=t.size_left+t.piece.length,n+=t.lf_left+t.piece.lineFeedCnt,t.right===f.Nc){const t=s-e-this.getOffsetAt(n+1,1);return new i.L(n+1,t+1)}t=t.right}return new i.L(1,1)}getValueInRange(e,t){if(e.startLineNumber===e.endLineNumber&&e.startColumn===e.endColumn)return"";const n=this.nodeAt2(e.startLineNumber,e.startColumn),i=this.nodeAt2(e.endLineNumber,e.endColumn),s=this.getValueInRange2(n,i);return t?t===this._EOL&&this._EOLNormalized&&t===this.getEOL()&&this._EOLNormalized?s:s.replace(/\r\n|\r|\n/g,t):s}getValueInRange2(e,t){if(e.node===t.node){const n=e.node,i=this._buffers[n.piece.bufferIndex].buffer,s=this.offsetInBuffer(n.piece.bufferIndex,n.piece.start);return i.substring(s+e.remainder,s+t.remainder)}let n=e.node;const i=this._buffers[n.piece.bufferIndex].buffer,s=this.offsetInBuffer(n.piece.bufferIndex,n.piece.start);let r=i.substring(s+e.remainder,s+n.piece.length);for(n=n.next();n!==f.Nc;){const e=this._buffers[n.piece.bufferIndex].buffer,i=this.offsetInBuffer(n.piece.bufferIndex,n.piece.start);if(n===t.node){r+=e.substring(i,i+t.remainder);break}r+=e.substr(i,n.piece.length),n=n.next()}return r}getLinesContent(){const e=[];let t=0,n="",i=!1;return this.iterate(this.root,(s=>{if(s===f.Nc)return!0;const r=s.piece;let h=r.length;if(0===h)return!0;const l=this._buffers[r.bufferIndex].buffer,u=this._buffers[r.bufferIndex].lineStarts,o=r.start.line,c=r.end.line;let d=u[o]+r.start.column;if(i&&(10===l.charCodeAt(d)&&(d++,h--),e[t++]=n,n="",i=!1,0===h))return!0;if(o===c)return this._EOLNormalized||13!==l.charCodeAt(d+h-1)?n+=l.substr(d,h):(i=!0,n+=l.substr(d,h-1)),!0;n+=this._EOLNormalized?l.substring(d,Math.max(d,u[o+1]-this._EOLLength)):l.substring(d,u[o+1]).replace(/(\r\n|\r|\n)$/,""),e[t++]=n;for(let i=o+1;i<c;i++)n=this._EOLNormalized?l.substring(u[i],u[i+1]-this._EOLLength):l.substring(u[i],u[i+1]).replace(/(\r\n|\r|\n)$/,""),e[t++]=n;return this._EOLNormalized||13!==l.charCodeAt(u[c]+r.end.column-1)?n=l.substr(u[c],r.end.column):(i=!0,0===r.end.column?t--:n=l.substr(u[c],r.end.column-1)),!0})),i&&(e[t++]=n,n=""),e[t++]=n,e}getLength(){return this._length}getLineCount(){return this._lineCnt}getLineContent(e){return this._lastVisitedLine.lineNumber===e||(this._lastVisitedLine.lineNumber=e,e===this._lineCnt?this._lastVisitedLine.value=this.getLineRawContent(e):this._EOLNormalized?this._lastVisitedLine.value=this.getLineRawContent(e,this._EOLLength):this._lastVisitedLine.value=this.getLineRawContent(e).replace(/(\r\n|\r|\n)$/,"")),this._lastVisitedLine.value}_getCharCode(e){if(e.remainder===e.node.piece.length){const t=e.node.next();if(!t)return 0;const n=this._buffers[t.piece.bufferIndex],i=this.offsetInBuffer(t.piece.bufferIndex,t.piece.start);return n.buffer.charCodeAt(i)}{const t=this._buffers[e.node.piece.bufferIndex],n=this.offsetInBuffer(e.node.piece.bufferIndex,e.node.piece.start)+e.remainder;return t.buffer.charCodeAt(n)}}getLineCharCode(e,t){const n=this.nodeAt2(e,t+1);return this._getCharCode(n)}getLineLength(e){if(e===this.getLineCount()){const t=this.getOffsetAt(e,1);return this.getLength()-t}return this.getOffsetAt(e+1,1)-this.getOffsetAt(e,1)-this._EOLLength}findMatchesInNode(e,t,n,i,r,f,l,u,o,c,d){const a=this._buffers[e.piece.bufferIndex],g=this.offsetInBuffer(e.piece.bufferIndex,e.piece.start),b=this.offsetInBuffer(e.piece.bufferIndex,r),p=this.offsetInBuffer(e.piece.bufferIndex,f);let _;const C={line:0,column:0};let m,I;t._wordSeparators?(m=a.buffer.substring(b,p),I=e=>e+b,t.reset(0)):(m=a.buffer,I=e=>e,t.reset(b));do{if(_=t.next(m),_){if(I(_.index)>=p)return c;this.positionInBuffer(e,I(_.index)-g,C);const t=this.getLineFeedCnt(e.piece.bufferIndex,r,C),f=C.line===r.line?C.column-r.column+i:C.column+1,l=f+_[0].length;if(d[c++]=(0,h.iE)(new s.e(n+t,f,n+t,l),_,u),I(_.index)+_[0].length>=p)return c;if(c>=o)return c}}while(_);return c}findMatchesLineByLine(e,t,n,i){const s=[];let r=0;const f=new h.sz(t.wordSeparators,t.regex);let l=this.nodeAt2(e.startLineNumber,e.startColumn);if(null===l)return[];const u=this.nodeAt2(e.endLineNumber,e.endColumn);if(null===u)return[];let o=this.positionInBuffer(l.node,l.remainder);const c=this.positionInBuffer(u.node,u.remainder);if(l.node===u.node)return this.findMatchesInNode(l.node,f,e.startLineNumber,e.startColumn,o,c,t,n,i,r,s),s;let d=e.startLineNumber,a=l.node;for(;a!==u.node;){const h=this.getLineFeedCnt(a.piece.bufferIndex,o,a.piece.end);if(h>=1){const l=this._buffers[a.piece.bufferIndex].lineStarts,u=this.offsetInBuffer(a.piece.bufferIndex,a.piece.start),c=l[o.line+h],g=d===e.startLineNumber?e.startColumn:1;if(r=this.findMatchesInNode(a,f,d,g,o,this.positionInBuffer(a,c-u),t,n,i,r,s),r>=i)return s;d+=h}const u=d===e.startLineNumber?e.startColumn-1:0;if(d===e.endLineNumber){const h=this.getLineContent(d).substring(u,e.endColumn-1);return r=this._findMatchesInLine(t,f,h,e.endLineNumber,u,r,s,n,i),s}if(r=this._findMatchesInLine(t,f,this.getLineContent(d).substr(u),d,u,r,s,n,i),r>=i)return s;d++,l=this.nodeAt2(d,1),a=l.node,o=this.positionInBuffer(l.node,l.remainder)}if(d===e.endLineNumber){const h=d===e.startLineNumber?e.startColumn-1:0,l=this.getLineContent(d).substring(h,e.endColumn-1);return r=this._findMatchesInLine(t,f,l,e.endLineNumber,h,r,s,n,i),s}const g=d===e.startLineNumber?e.startColumn:1;return r=this.findMatchesInNode(u.node,f,d,g,o,c,t,n,i,r,s),s}_findMatchesInLine(e,t,n,i,f,l,u,o,c){const d=e.wordSeparators;if(!o&&e.simpleSearch){const t=e.simpleSearch,o=t.length,a=n.length;let g=-o;for(;-1!==(g=n.indexOf(t,g+o));)if((!d||(0,h.cM)(d,n,a,g,o))&&(u[l++]=new r.tk(new s.e(i,g+1+f,i,g+1+o+f),null),l>=c))return l;return l}let a;t.reset(0);do{if(a=t.next(n),a&&(u[l++]=(0,h.iE)(new s.e(i,a.index+1+f,i,a.index+1+a[0].length+f),a,o),l>=c))return l}while(a);return l}insert(e,t,n=!1){if(this._EOLNormalized=this._EOLNormalized&&n,this._lastVisitedLine.lineNumber=0,this._lastVisitedLine.value="",this.root!==f.Nc){const{node:n,remainder:i,nodeStartOffset:s}=this.nodeAt(e),r=n.piece,f=r.bufferIndex,h=this.positionInBuffer(n,i);if(0===n.piece.bufferIndex&&r.end.line===this._lastChangeBufferPos.line&&r.end.column===this._lastChangeBufferPos.column&&s+r.length===e&&t.length<l)return this.appendToNode(n,t),void this.computeBufferMetadata();if(s===e)this.insertContentToNodeLeft(t,n),this._searchCache.validate(e);else if(s+n.piece.length>e){const e=[];let s=new a(r.bufferIndex,h,r.end,this.getLineFeedCnt(r.bufferIndex,h,r.end),this.offsetInBuffer(f,r.end)-this.offsetInBuffer(f,h));if(this.shouldCheckCRLF()&&this.endWithCR(t)){if(10===this.nodeCharCodeAt(n,i)){const e={line:s.start.line+1,column:0};s=new a(s.bufferIndex,e,s.end,this.getLineFeedCnt(s.bufferIndex,e,s.end),s.length-1),t+="\n"}}if(this.shouldCheckCRLF()&&this.startWithLF(t)){if(13===this.nodeCharCodeAt(n,i-1)){const s=this.positionInBuffer(n,i-1);this.deleteNodeTail(n,s),t="\r"+t,0===n.piece.length&&e.push(n)}else this.deleteNodeTail(n,h)}else this.deleteNodeTail(n,h);const l=this.createNewPieces(t);s.length>0&&this.rbInsertRight(n,s);let u=n;for(let e=0;e<l.length;e++)u=this.rbInsertRight(u,l[e]);this.deleteNodes(e)}else this.insertContentToNodeRight(t,n)}else{const e=this.createNewPieces(t);let n=this.rbInsertLeft(null,e[0]);for(let t=1;t<e.length;t++)n=this.rbInsertRight(n,e[t])}this.computeBufferMetadata()}delete(e,t){if(this._lastVisitedLine.lineNumber=0,this._lastVisitedLine.value="",t<=0||this.root===f.Nc)return;const n=this.nodeAt(e),i=this.nodeAt(e+t),s=n.node,r=i.node;if(s===r){const r=this.positionInBuffer(s,n.remainder),h=this.positionInBuffer(s,i.remainder);if(n.nodeStartOffset===e){if(t===s.piece.length){const e=s.next();return(0,f.KI)(this,s),this.validateCRLFWithPrevNode(e),void this.computeBufferMetadata()}return this.deleteNodeHead(s,h),this._searchCache.validate(e),this.validateCRLFWithPrevNode(s),void this.computeBufferMetadata()}return n.nodeStartOffset+s.piece.length===e+t?(this.deleteNodeTail(s,r),this.validateCRLFWithNextNode(s),void this.computeBufferMetadata()):(this.shrinkNode(s,r,h),void this.computeBufferMetadata())}const h=[],l=this.positionInBuffer(s,n.remainder);this.deleteNodeTail(s,l),this._searchCache.validate(e),0===s.piece.length&&h.push(s);const u=this.positionInBuffer(r,i.remainder);this.deleteNodeHead(r,u),0===r.piece.length&&h.push(r);for(let e=s.next();e!==f.Nc&&e!==r;e=e.next())h.push(e);const o=0===s.piece.length?s.prev():s;this.deleteNodes(h),this.validateCRLFWithNextNode(o),this.computeBufferMetadata()}insertContentToNodeLeft(e,t){const n=[];if(this.shouldCheckCRLF()&&this.endWithCR(e)&&this.startWithLF(t)){const i=t.piece,s={line:i.start.line+1,column:0},r=new a(i.bufferIndex,s,i.end,this.getLineFeedCnt(i.bufferIndex,s,i.end),i.length-1);t.piece=r,e+="\n",(0,f.Z2)(this,t,-1,-1),0===t.piece.length&&n.push(t)}const i=this.createNewPieces(e);let s=this.rbInsertLeft(t,i[i.length-1]);for(let e=i.length-2;e>=0;e--)s=this.rbInsertLeft(s,i[e]);this.validateCRLFWithPrevNode(s),this.deleteNodes(n)}insertContentToNodeRight(e,t){this.adjustCarriageReturnFromNext(e,t)&&(e+="\n");const n=this.createNewPieces(e),i=this.rbInsertRight(t,n[0]);let s=i;for(let e=1;e<n.length;e++)s=this.rbInsertRight(s,n[e]);this.validateCRLFWithPrevNode(i)}positionInBuffer(e,t,n){const i=e.piece,s=e.piece.bufferIndex,r=this._buffers[s].lineStarts,f=r[i.start.line]+i.start.column+t;let h=i.start.line,l=i.end.line,u=0,o=0,c=0;for(;h<=l&&(u=h+(l-h)/2|0,c=r[u],u!==l);)if(o=r[u+1],f<c)l=u-1;else{if(!(f>=o))break;h=u+1}return n?(n.line=u,n.column=f-c,null):{line:u,column:f-c}}getLineFeedCnt(e,t,n){if(0===n.column)return n.line-t.line;const i=this._buffers[e].lineStarts;if(n.line===i.length-1)return n.line-t.line;const s=i[n.line+1],r=i[n.line]+n.column;if(s>r+1)return n.line-t.line;const f=r-1;return 13===this._buffers[e].buffer.charCodeAt(f)?n.line-t.line+1:n.line-t.line}offsetInBuffer(e,t){return this._buffers[e].lineStarts[t.line]+t.column}deleteNodes(e){for(let t=0;t<e.length;t++)(0,f.KI)(this,e[t])}createNewPieces(e){if(e.length>l){const t=[];for(;e.length>l;){const n=e.charCodeAt(65534);let i;13===n||n>=55296&&n<=56319?(i=e.substring(0,65534),e=e.substring(65534)):(i=e.substring(0,l),e=e.substring(l));const s=c(i);t.push(new a(this._buffers.length,{line:0,column:0},{line:s.length-1,column:i.length-s[s.length-1]},s.length-1,i.length)),this._buffers.push(new g(i,s))}const n=c(e);return t.push(new a(this._buffers.length,{line:0,column:0},{line:n.length-1,column:e.length-n[n.length-1]},n.length-1,e.length)),this._buffers.push(new g(e,n)),t}let t=this._buffers[0].buffer.length;const n=c(e,!1);let i=this._lastChangeBufferPos;if(this._buffers[0].lineStarts[this._buffers[0].lineStarts.length-1]===t&&0!==t&&this.startWithLF(e)&&this.endWithCR(this._buffers[0].buffer)){this._lastChangeBufferPos={line:this._lastChangeBufferPos.line,column:this._lastChangeBufferPos.column+1},i=this._lastChangeBufferPos;for(let e=0;e<n.length;e++)n[e]+=t+1;this._buffers[0].lineStarts=this._buffers[0].lineStarts.concat(n.slice(1)),this._buffers[0].buffer+="_"+e,t+=1}else{if(0!==t)for(let e=0;e<n.length;e++)n[e]+=t;this._buffers[0].lineStarts=this._buffers[0].lineStarts.concat(n.slice(1)),this._buffers[0].buffer+=e}const s=this._buffers[0].buffer.length,r=this._buffers[0].lineStarts.length-1,f={line:r,column:s-this._buffers[0].lineStarts[r]},h=new a(0,i,f,this.getLineFeedCnt(0,i,f),s-t);return this._lastChangeBufferPos=f,[h]}getLineRawContent(e,t=0){let n=this.root,i="";const s=this._searchCache.get2(e);if(s){n=s.node;const r=this.getAccumulatedValue(n,e-s.nodeStartLineNumber-1),f=this._buffers[n.piece.bufferIndex].buffer,h=this.offsetInBuffer(n.piece.bufferIndex,n.piece.start);if(s.nodeStartLineNumber+n.piece.lineFeedCnt!==e){const i=this.getAccumulatedValue(n,e-s.nodeStartLineNumber);return f.substring(h+r,h+i-t)}i=f.substring(h+r,h+n.piece.length)}else{let s=0;const r=e;for(;n!==f.Nc;)if(n.left!==f.Nc&&n.lf_left>=e-1)n=n.left;else{if(n.lf_left+n.piece.lineFeedCnt>e-1){const i=this.getAccumulatedValue(n,e-n.lf_left-2),f=this.getAccumulatedValue(n,e-n.lf_left-1),h=this._buffers[n.piece.bufferIndex].buffer,l=this.offsetInBuffer(n.piece.bufferIndex,n.piece.start);return s+=n.size_left,this._searchCache.set({node:n,nodeStartOffset:s,nodeStartLineNumber:r-(e-1-n.lf_left)}),h.substring(l+i,l+f-t)}if(n.lf_left+n.piece.lineFeedCnt===e-1){const t=this.getAccumulatedValue(n,e-n.lf_left-2),s=this._buffers[n.piece.bufferIndex].buffer,r=this.offsetInBuffer(n.piece.bufferIndex,n.piece.start);i=s.substring(r+t,r+n.piece.length);break}e-=n.lf_left+n.piece.lineFeedCnt,s+=n.size_left+n.piece.length,n=n.right}}for(n=n.next();n!==f.Nc;){const e=this._buffers[n.piece.bufferIndex].buffer;if(n.piece.lineFeedCnt>0){const s=this.getAccumulatedValue(n,0),r=this.offsetInBuffer(n.piece.bufferIndex,n.piece.start);return i+=e.substring(r,r+s-t),i}{const t=this.offsetInBuffer(n.piece.bufferIndex,n.piece.start);i+=e.substr(t,n.piece.length)}n=n.next()}return i}computeBufferMetadata(){let e=this.root,t=1,n=0;for(;e!==f.Nc;)t+=e.lf_left+e.piece.lineFeedCnt,n+=e.size_left+e.piece.length,e=e.right;this._lineCnt=t,this._length=n,this._searchCache.validate(this._length)}getIndexOf(e,t){const n=e.piece,i=this.positionInBuffer(e,t),s=i.line-n.start.line;if(this.offsetInBuffer(n.bufferIndex,n.end)-this.offsetInBuffer(n.bufferIndex,n.start)===t){const t=this.getLineFeedCnt(e.piece.bufferIndex,n.start,i);if(t!==s)return{index:t,remainder:0}}return{index:s,remainder:i.column}}getAccumulatedValue(e,t){if(t<0)return 0;const n=e.piece,i=this._buffers[n.bufferIndex].lineStarts,s=n.start.line+t+1;return s>n.end.line?i[n.end.line]+n.end.column-i[n.start.line]-n.start.column:i[s]-i[n.start.line]-n.start.column}deleteNodeTail(e,t){const n=e.piece,i=n.lineFeedCnt,s=this.offsetInBuffer(n.bufferIndex,n.end),r=t,h=this.offsetInBuffer(n.bufferIndex,r),l=this.getLineFeedCnt(n.bufferIndex,n.start,r),u=l-i,o=h-s,c=n.length+o;e.piece=new a(n.bufferIndex,n.start,r,l,c),(0,f.Z2)(this,e,o,u)}deleteNodeHead(e,t){const n=e.piece,i=n.lineFeedCnt,s=this.offsetInBuffer(n.bufferIndex,n.start),r=t,h=this.getLineFeedCnt(n.bufferIndex,r,n.end),l=h-i,u=s-this.offsetInBuffer(n.bufferIndex,r),o=n.length+u;e.piece=new a(n.bufferIndex,r,n.end,h,o),(0,f.Z2)(this,e,u,l)}shrinkNode(e,t,n){const i=e.piece,s=i.start,r=i.end,h=i.length,l=i.lineFeedCnt,u=t,o=this.getLineFeedCnt(i.bufferIndex,i.start,u),c=this.offsetInBuffer(i.bufferIndex,t)-this.offsetInBuffer(i.bufferIndex,s);e.piece=new a(i.bufferIndex,i.start,u,o,c),(0,f.Z2)(this,e,c-h,o-l);const d=new a(i.bufferIndex,n,r,this.getLineFeedCnt(i.bufferIndex,n,r),this.offsetInBuffer(i.bufferIndex,r)-this.offsetInBuffer(i.bufferIndex,n)),g=this.rbInsertRight(e,d);this.validateCRLFWithPrevNode(g)}appendToNode(e,t){this.adjustCarriageReturnFromNext(t,e)&&(t+="\n");const n=this.shouldCheckCRLF()&&this.startWithLF(t)&&this.endWithCR(e),i=this._buffers[0].buffer.length;this._buffers[0].buffer+=t;const s=c(t,!1);for(let e=0;e<s.length;e++)s[e]+=i;if(n){const e=this._buffers[0].lineStarts[this._buffers[0].lineStarts.length-2];this._buffers[0].lineStarts.pop(),this._lastChangeBufferPos={line:this._lastChangeBufferPos.line-1,column:i-e}}this._buffers[0].lineStarts=this._buffers[0].lineStarts.concat(s.slice(1));const r=this._buffers[0].lineStarts.length-1,h={line:r,column:this._buffers[0].buffer.length-this._buffers[0].lineStarts[r]},l=e.piece.length+t.length,u=e.piece.lineFeedCnt,o=this.getLineFeedCnt(0,e.piece.start,h),d=o-u;e.piece=new a(e.piece.bufferIndex,e.piece.start,h,o,l),this._lastChangeBufferPos=h,(0,f.Z2)(this,e,t.length,d)}nodeAt(e){let t=this.root;const n=this._searchCache.get(e);if(n)return{node:n.node,nodeStartOffset:n.nodeStartOffset,remainder:e-n.nodeStartOffset};let i=0;for(;t!==f.Nc;)if(t.size_left>e)t=t.left;else{if(t.size_left+t.piece.length>=e){i+=t.size_left;const n={node:t,remainder:e-t.size_left,nodeStartOffset:i};return this._searchCache.set(n),n}e-=t.size_left+t.piece.length,i+=t.size_left+t.piece.length,t=t.right}return null}nodeAt2(e,t){let n=this.root,i=0;for(;n!==f.Nc;)if(n.left!==f.Nc&&n.lf_left>=e-1)n=n.left;else{if(n.lf_left+n.piece.lineFeedCnt>e-1){const s=this.getAccumulatedValue(n,e-n.lf_left-2),r=this.getAccumulatedValue(n,e-n.lf_left-1);return i+=n.size_left,{node:n,remainder:Math.min(s+t-1,r),nodeStartOffset:i}}if(n.lf_left+n.piece.lineFeedCnt===e-1){const s=this.getAccumulatedValue(n,e-n.lf_left-2);if(s+t-1<=n.piece.length)return{node:n,remainder:s+t-1,nodeStartOffset:i};t-=n.piece.length-s;break}e-=n.lf_left+n.piece.lineFeedCnt,i+=n.size_left+n.piece.length,n=n.right}for(n=n.next();n!==f.Nc;){if(n.piece.lineFeedCnt>0){const e=this.getAccumulatedValue(n,0),i=this.offsetOfNode(n);return{node:n,remainder:Math.min(t-1,e),nodeStartOffset:i}}if(n.piece.length>=t-1){return{node:n,remainder:t-1,nodeStartOffset:this.offsetOfNode(n)}}t-=n.piece.length,n=n.next()}return null}nodeCharCodeAt(e,t){if(e.piece.lineFeedCnt<1)return-1;const n=this._buffers[e.piece.bufferIndex],i=this.offsetInBuffer(e.piece.bufferIndex,e.piece.start)+t;return n.buffer.charCodeAt(i)}offsetOfNode(e){if(!e)return 0;let t=e.size_left;for(;e!==this.root;)e.parent.right===e&&(t+=e.parent.size_left+e.parent.piece.length),e=e.parent;return t}shouldCheckCRLF(){return!(this._EOLNormalized&&"\n"===this._EOL)}startWithLF(e){if("string"==typeof e)return 10===e.charCodeAt(0);if(e===f.Nc||0===e.piece.lineFeedCnt)return!1;const t=e.piece,n=this._buffers[t.bufferIndex].lineStarts,i=t.start.line,s=n[i]+t.start.column;if(i===n.length-1)return!1;return!(n[i+1]>s+1)&&10===this._buffers[t.bufferIndex].buffer.charCodeAt(s)}endWithCR(e){return"string"==typeof e?13===e.charCodeAt(e.length-1):e!==f.Nc&&0!==e.piece.lineFeedCnt&&13===this.nodeCharCodeAt(e,e.piece.length-1)}validateCRLFWithPrevNode(e){if(this.shouldCheckCRLF()&&this.startWithLF(e)){const t=e.prev();this.endWithCR(t)&&this.fixCRLF(t,e)}}validateCRLFWithNextNode(e){if(this.shouldCheckCRLF()&&this.endWithCR(e)){const t=e.next();this.startWithLF(t)&&this.fixCRLF(e,t)}}fixCRLF(e,t){const n=[],i=this._buffers[e.piece.bufferIndex].lineStarts;let s;s=0===e.piece.end.column?{line:e.piece.end.line-1,column:i[e.piece.end.line]-i[e.piece.end.line-1]-1}:{line:e.piece.end.line,column:e.piece.end.column-1};const r=e.piece.length-1,h=e.piece.lineFeedCnt-1;e.piece=new a(e.piece.bufferIndex,e.piece.start,s,h,r),(0,f.Z2)(this,e,-1,-1),0===e.piece.length&&n.push(e);const l={line:t.piece.start.line+1,column:0},u=t.piece.length-1,o=this.getLineFeedCnt(t.piece.bufferIndex,l,t.piece.end);t.piece=new a(t.piece.bufferIndex,l,t.piece.end,o,u),(0,f.Z2)(this,t,-1,-1),0===t.piece.length&&n.push(t);const c=this.createNewPieces("\r\n");this.rbInsertRight(e,c[0]);for(let e=0;e<n.length;e++)(0,f.KI)(this,n[e])}adjustCarriageReturnFromNext(e,t){if(this.shouldCheckCRLF()&&this.endWithCR(e)){const n=t.next();if(this.startWithLF(n)){if(e+="\n",1===n.piece.length)(0,f.KI)(this,n);else{const e=n.piece,t={line:e.start.line+1,column:0},i=e.length-1,s=this.getLineFeedCnt(e.bufferIndex,t,e.end);n.piece=new a(e.bufferIndex,t,e.end,s,i),(0,f.Z2)(this,n,-1,-1)}return!0}}return!1}iterate(e,t){if(e===f.Nc)return t(f.Nc);const n=this.iterate(e.left,t);return n?t(e)&&this.iterate(e.right,t):n}getNodeContent(e){if(e===f.Nc)return"";const t=this._buffers[e.piece.bufferIndex],n=e.piece,i=this.offsetInBuffer(n.bufferIndex,n.start),s=this.offsetInBuffer(n.bufferIndex,n.end);return t.buffer.substring(i,s)}getPieceContent(e){const t=this._buffers[e.bufferIndex],n=this.offsetInBuffer(e.bufferIndex,e.start),i=this.offsetInBuffer(e.bufferIndex,e.end);return t.buffer.substring(n,i)}rbInsertRight(e,t){const n=new f.OF(t,1);n.left=f.Nc,n.right=f.Nc,n.parent=f.Nc,n.size_left=0,n.lf_left=0;if(this.root===f.Nc)this.root=n,n.color=0;else if(e.right===f.Nc)e.right=n,n.parent=e;else{const t=(0,f.xq)(e.right);t.left=n,n.parent=t}return(0,f.h4)(this,n),n}rbInsertLeft(e,t){const n=new f.OF(t,1);if(n.left=f.Nc,n.right=f.Nc,n.parent=f.Nc,n.size_left=0,n.lf_left=0,this.root===f.Nc)this.root=n,n.color=0;else if(e.left===f.Nc)e.left=n,n.parent=e;else{const t=(0,f.Q$)(e.left);t.right=n,n.parent=t}return(0,f.h4)(this,n),n}}}}]);