"use strict";(self.webpackChunkapp_template_builder=self.webpackChunkapp_template_builder||[]).push([[2964],{74450:function(e,l,t){t.d(l,{Z:function(){return n}});var a=t(27875);function n(e){const l=(0,a.FN)();(0,a.wF)((()=>{t.value.addObserver(l)})),(0,a.bv)((()=>{n(t.value),o(t.value)})),(0,a.ic)((()=>{n(t.value),o(t.value)})),(0,a.Ah)((()=>{t.value.removeObserver(l)}));const t=(0,a.Fl)((()=>{const l=e.layout;if(!l)throw new Error("Can not find table layout.");return l})),n=l=>{var t;const a=(null==(t=e.vnode.el)?void 0:t.querySelectorAll("colgroup > col"))||[];if(!a.length)return;const n=l.getFlattenColumns(),o={};n.forEach((e=>{o[e.id]=e}));for(let e=0,l=a.length;e<l;e++){const l=a[e],t=l.getAttribute("name"),n=o[t];n&&l.setAttribute("width",n.realWidth||n.width)}},o=l=>{var t,a;const n=(null==(t=e.vnode.el)?void 0:t.querySelectorAll("colgroup > col[name=gutter]"))||[];for(let e=0,t=n.length;e<t;e++){n[e].setAttribute("width",l.scrollY.value?l.gutterWidth:"0")}const o=(null==(a=e.vnode.el)?void 0:a.querySelectorAll("th.gutter"))||[];for(let e=0,t=o.length;e<t;e++){const t=o[e];t.style.width=l.scrollY.value?`${l.gutterWidth}px`:"0",t.style.display=l.scrollY.value?"":"none"}};return{tableLayout:t.value,onColumnsChange:n,onScrollableChange:o}}},66501:function(e,l,t){t.d(l,{M:function(){return f}});var a=t(27875),n=t(92322),o=t(40641),r=t(72713);var u=t(50349);const s=e=>{const l=[];return e.forEach((e=>{e.children?l.push.apply(l,s(e.children)):l.push(e)})),l};function i(){var e;const l=(0,a.FN)(),{size:t}=(0,o.BK)(null==(e=l.proxy)?void 0:e.$props),n=(0,o.iH)(null),i=(0,o.iH)([]),c=(0,o.iH)([]),d=(0,o.iH)(!1),v=(0,o.iH)([]),h=(0,o.iH)([]),p=(0,o.iH)([]),f=(0,o.iH)([]),g=(0,o.iH)([]),y=(0,o.iH)([]),m=(0,o.iH)([]),w=(0,o.iH)([]),x=(0,o.iH)(0),C=(0,o.iH)(0),S=(0,o.iH)(0),E=(0,o.iH)(!1),R=(0,o.iH)([]),b=(0,o.iH)(!1),K=(0,o.iH)(!1),H=(0,o.iH)(null),O=(0,o.iH)({}),A=(0,o.iH)(null),k=(0,o.iH)(null),T=(0,o.iH)(null),F=(0,o.iH)(null),W=(0,o.iH)(null);(0,a.YP)(i,(()=>l.state&&L(!1)),{deep:!0});const _=()=>{f.value=v.value.filter((e=>!0===e.fixed||"left"===e.fixed)),g.value=v.value.filter((e=>"right"===e.fixed)),f.value.length>0&&v.value[0]&&"selection"===v.value[0].type&&!v.value[0].fixed&&(v.value[0].fixed=!0,f.value.unshift(v.value[0]));const e=v.value.filter((e=>!e.fixed));h.value=[].concat(f.value).concat(e).concat(g.value);const l=s(e),t=s(f.value),a=s(g.value);x.value=l.length,C.value=t.length,S.value=a.length,p.value=[].concat(t).concat(l).concat(a),d.value=f.value.length>0||g.value.length>0},L=(e,t=!1)=>{e&&_(),t?l.state.doLayout():l.state.debouncedUpdateLayout()},Y=e=>{var t;if(!l||!l.store)return 0;const{treeData:a}=l.store.states;let n=0;const o=null==(t=a.value[e])?void 0:t.children;return o&&(n+=o.length,o.forEach((e=>{n+=Y(e)}))),n},U=(e,l,t)=>{k.value&&k.value!==e&&(k.value.order=null),k.value=e,T.value=l,F.value=t},D=()=>{let e=(0,o.SU)(c);Object.keys(O.value).forEach((l=>{const t=O.value[l];if(!t||0===t.length)return;const a=(0,r.UM)({columns:p.value},l);a&&a.filterMethod&&(e=e.filter((e=>t.some((l=>a.filterMethod.call(null,l,e,a))))))})),A.value=e},P=()=>{i.value=((e,l)=>{const t=l.sortingColumn;return t&&"string"!=typeof t.sortable?(0,r.Xo)(e,l.sortProp,l.sortOrder,t.sortMethod,t.sortBy):e})(A.value,{sortingColumn:k.value,sortProp:T.value,sortOrder:F.value})},{setExpandRowKeys:z,toggleRowExpansion:j,updateExpandRows:B,states:N,isRowExpanded:I}=function(e){const l=(0,a.FN)(),t=(0,o.iH)(!1),n=(0,o.iH)([]);return{updateExpandRows:()=>{const l=e.data.value||[],a=e.rowKey.value;if(t.value)n.value=l.slice();else if(a){const e=(0,r.kr)(n.value,a);n.value=l.reduce(((l,t)=>{const n=(0,r.WO)(t,a);return e[n]&&l.push(t),l}),[])}else n.value=[]},toggleRowExpansion:(e,t)=>{(0,r.iB)(n.value,e,t)&&l.emit("expand-change",e,n.value.slice())},setExpandRowKeys:t=>{l.store.assertRowKey();const a=e.data.value||[],o=e.rowKey.value,u=(0,r.kr)(a,o);n.value=t.reduce(((e,l)=>{const t=u[l];return t&&e.push(t.row),e}),[])},isRowExpanded:l=>{const t=e.rowKey.value;return t?!!(0,r.kr)(n.value,t)[(0,r.WO)(l,t)]:n.value.includes(l)},states:{expandRows:n,defaultExpandAll:t}}}({data:i,rowKey:n}),{updateTreeExpandKeys:$,toggleTreeExpansion:M,updateTreeData:q,loadOrToggle:Q,states:V}=function(e){const l=(0,o.iH)([]),t=(0,o.iH)({}),n=(0,o.iH)(16),u=(0,o.iH)(!1),s=(0,o.iH)({}),i=(0,o.iH)("hasChildren"),c=(0,o.iH)("children"),d=(0,a.FN)(),v=(0,a.Fl)((()=>{if(!e.rowKey.value)return{};const l=e.data.value||[];return p(l)})),h=(0,a.Fl)((()=>{const l=e.rowKey.value,t=Object.keys(s.value),a={};return t.length?(t.forEach((e=>{if(s.value[e].length){const t={children:[]};s.value[e].forEach((e=>{const n=(0,r.WO)(e,l);t.children.push(n),e[i.value]&&!a[n]&&(a[n]={children:[]})})),a[e]=t}})),a):a})),p=l=>{const t=e.rowKey.value,a={};return(0,r.L$)(l,((e,l,n)=>{const o=(0,r.WO)(e,t);Array.isArray(l)?a[o]={children:l.map((e=>(0,r.WO)(e,t))),level:n}:u.value&&(a[o]={children:[],lazy:!0,level:n})}),c.value,i.value),a},f=(e=!1,a=(e=>null==(e=d.store)?void 0:e.states.defaultExpandAll.value)())=>{var n;const r=v.value,s=h.value,i=Object.keys(r),c={};if(i.length){const n=(0,o.SU)(t),d=[],v=(t,n)=>{if(e)return l.value?a||l.value.includes(n):!(!a&&!(null==t?void 0:t.expanded));{const e=a||l.value&&l.value.includes(n);return!(!(null==t?void 0:t.expanded)&&!e)}};i.forEach((e=>{const l=n[e],t={...r[e]};if(t.expanded=v(l,e),t.lazy){const{loaded:a=!1,loading:n=!1}=l||{};t.loaded=!!a,t.loading=!!n,d.push(e)}c[e]=t}));const h=Object.keys(s);u.value&&h.length&&d.length&&h.forEach((e=>{const l=n[e],t=s[e].children;if(d.includes(e)){if(0!==c[e].children.length)throw new Error("[ElTable]children must be an empty array.");c[e].children=t}else{const{loaded:a=!1,loading:n=!1}=l||{};c[e]={lazy:!0,loaded:!!a,loading:!!n,expanded:v(l,e),children:t,level:""}}}))}t.value=c,null==(n=d.store)||n.updateTableScrollY()};(0,a.YP)((()=>l.value),(()=>{f(!0)})),(0,a.YP)((()=>v.value),(()=>{f()})),(0,a.YP)((()=>h.value),(()=>{f()}));const g=(l,a)=>{d.store.assertRowKey();const n=e.rowKey.value,o=(0,r.WO)(l,n),u=o&&t.value[o];if(o&&u&&"expanded"in u){const e=u.expanded;a=void 0===a?!u.expanded:a,t.value[o].expanded=a,e!==a&&d.emit("expand-change",l,a),d.store.updateTableScrollY()}},y=(e,l,a)=>{const{load:n}=d.props;n&&!t.value[l].loaded&&(t.value[l].loading=!0,n(e,a,(a=>{if(!Array.isArray(a))throw new TypeError("[ElTable] data must be an array");t.value[l].loading=!1,t.value[l].loaded=!0,t.value[l].expanded=!0,a.length&&(s.value[l]=a),d.emit("expand-change",e,!0)})))};return{loadData:y,loadOrToggle:l=>{d.store.assertRowKey();const a=e.rowKey.value,n=(0,r.WO)(l,a),o=t.value[n];u.value&&o&&"loaded"in o&&!o.loaded?y(l,n,o):g(l,void 0)},toggleTreeExpansion:g,updateTreeExpandKeys:e=>{l.value=e,f()},updateTreeData:f,normalize:p,states:{expandRowKeys:l,treeData:t,indent:n,lazy:u,lazyTreeNodeMap:s,lazyColumnIdentifier:i,childrenColumnName:c}}}({data:i,rowKey:n}),{updateCurrentRowData:Z,updateCurrentRow:X,setCurrentRowKey:G,states:J}=function(e){const l=(0,a.FN)(),t=(0,o.iH)(null),n=(0,o.iH)(null),u=()=>{t.value=null},s=t=>{const{data:a,rowKey:u}=e;let s=null;u.value&&(s=((0,o.SU)(a)||[]).find((e=>(0,r.WO)(e,u.value)===t))),n.value=s,l.emit("current-change",n.value,null)};return{setCurrentRowKey:e=>{l.store.assertRowKey(),t.value=e,s(e)},restoreCurrentRowKey:u,setCurrentRowByKey:s,updateCurrentRow:e=>{const t=n.value;if(e&&e!==t)return n.value=e,void l.emit("current-change",n.value,t);!e&&t&&(n.value=null,l.emit("current-change",null,t))},updateCurrentRowData:()=>{const a=e.rowKey.value,o=e.data.value||[],i=n.value;if(!o.includes(i)&&i){if(a){const e=(0,r.WO)(i,a);s(e)}else n.value=null;null===n.value&&l.emit("current-change",null,i)}else t.value&&(s(t.value),u())},states:{_currentRowKey:t,currentRow:n}}}({data:i,rowKey:n});return{assertRowKey:()=>{if(!n.value)throw new Error("[ElTable] prop row-key is required")},updateColumns:_,scheduleLayout:L,isSelected:e=>R.value.includes(e),clearSelection:()=>{E.value=!1;R.value.length&&(R.value=[],l.emit("selection-change",[]))},cleanSelection:()=>{let e;if(n.value){e=[];const l=(0,r.kr)(R.value,n.value),t=(0,r.kr)(i.value,n.value);for(const a in l)(0,u.hasOwn)(l,a)&&!t[a]&&e.push(l[a].row)}else e=R.value.filter((e=>!i.value.includes(e)));if(e.length){const t=R.value.filter((l=>!e.includes(l)));R.value=t,l.emit("selection-change",t.slice())}},getSelectionRows:()=>(R.value||[]).slice(),toggleRowSelection:(e,t,a=!0)=>{if((0,r.iB)(R.value,e,t)){const t=(R.value||[]).slice();a&&l.emit("select",t,e),l.emit("selection-change",t)}},_toggleAllSelection:()=>{var e,t;const a=K.value?!E.value:!(E.value||R.value.length);E.value=a;let n=!1,o=0;const u=null==(t=null==(e=null==l?void 0:l.store)?void 0:e.states)?void 0:t.rowKey.value;i.value.forEach(((e,l)=>{const t=l+o;H.value?H.value.call(null,e,t)&&(0,r.iB)(R.value,e,a)&&(n=!0):(0,r.iB)(R.value,e,a)&&(n=!0),o+=Y((0,r.WO)(e,u))})),n&&l.emit("selection-change",R.value?R.value.slice():[]),l.emit("select-all",R.value)},toggleAllSelection:null,updateSelectionByRowKey:()=>{const e=(0,r.kr)(R.value,n.value);i.value.forEach((l=>{const t=(0,r.WO)(l,n.value),a=e[t];a&&(R.value[a.index]=l)}))},updateAllSelected:()=>{var e,t,a;if(0===(null==(e=i.value)?void 0:e.length))return void(E.value=!1);let o;n.value&&(o=(0,r.kr)(R.value,n.value));let u=!0,s=0,c=0;for(let e=0,v=(i.value||[]).length;e<v;e++){const v=null==(a=null==(t=null==l?void 0:l.store)?void 0:t.states)?void 0:a.rowKey.value,h=e+c,p=i.value[e],f=H.value&&H.value.call(null,p,h);if(d=p,o?o[(0,r.WO)(d,n.value)]:R.value.includes(d))s++;else if(!H.value||f){u=!1;break}c+=Y((0,r.WO)(p,v))}var d;0===s&&(u=!1),E.value=u},updateFilters:(e,l)=>{Array.isArray(e)||(e=[e]);const t={};return e.forEach((e=>{O.value[e.id]=l,t[e.columnKey||e.id]=l})),t},updateCurrentRow:X,updateSort:U,execFilter:D,execSort:P,execQuery:e=>{e&&e.filter||D(),P()},clearFilter:e=>{const{tableHeaderRef:t}=l.refs;if(!t)return;const a=Object.assign({},t.filterPanels),n=Object.keys(a);if(n.length)if("string"==typeof e&&(e=[e]),Array.isArray(e)){const t=e.map((e=>(0,r.iO)({columns:p.value},e)));n.forEach((e=>{const l=t.find((l=>l.id===e));l&&(l.filteredValue=[])})),l.store.commit("filterChange",{column:t,values:[],silent:!0,multi:!0})}else n.forEach((e=>{const l=p.value.find((l=>l.id===e));l&&(l.filteredValue=[])})),O.value={},l.store.commit("filterChange",{column:{},values:[],silent:!0})},clearSort:()=>{k.value&&(U(null,null,null),l.store.commit("changeSortCondition",{silent:!0}))},toggleRowExpansion:j,setExpandRowKeysAdapter:e=>{z(e),$(e)},setCurrentRowKey:G,toggleRowExpansionAdapter:(e,l)=>{p.value.some((({type:e})=>"expand"===e))?j(e,l):M(e,l)},isRowExpanded:I,updateExpandRows:B,updateCurrentRowData:Z,loadOrToggle:Q,updateTreeData:q,states:{tableSize:t,rowKey:n,data:i,_data:c,isComplex:d,_columns:v,originColumns:h,columns:p,fixedColumns:f,rightFixedColumns:g,leafColumns:y,fixedLeafColumns:m,rightFixedLeafColumns:w,leafColumnsLength:x,fixedLeafColumnsLength:C,rightFixedLeafColumnsLength:S,isAllSelected:E,selection:R,reserveSelection:b,selectOnIndeterminate:K,selectable:H,filters:O,filteredData:A,sortingColumn:k,sortProp:T,sortOrder:F,hoverRow:W,...N,...V,...J}}}var c=t(29114);function d(e,l){return e.map((e=>{var t;return e.id===l.id?l:((null==(t=e.children)?void 0:t.length)&&(e.children=d(e.children,l)),e)}))}function v(e){e.forEach((e=>{var l,t;e.no=null==(l=e.getColumnIndex)?void 0:l.call(e),(null==(t=e.children)?void 0:t.length)&&v(e.children)})),e.sort(((e,l)=>e.no-l.no))}function h(){const e=(0,a.FN)(),l=i();return{ns:(0,c.s)("table"),...l,mutations:{setData(l,t){const a=(0,o.SU)(l._data)!==t;l.data.value=t,l._data.value=t,e.store.execQuery(),e.store.updateCurrentRowData(),e.store.updateExpandRows(),e.store.updateTreeData(e.store.states.defaultExpandAll.value),(0,o.SU)(l.reserveSelection)?(e.store.assertRowKey(),e.store.updateSelectionByRowKey()):a?e.store.clearSelection():e.store.cleanSelection(),e.store.updateAllSelected(),e.$ready&&e.store.scheduleLayout()},insertColumn(l,t,a){const n=(0,o.SU)(l._columns);let r=[];a?(a&&!a.children&&(a.children=[]),a.children.push(t),r=d(n,a)):(n.push(t),r=n),v(r),l._columns.value=r,"selection"===t.type&&(l.selectable.value=t.selectable,l.reserveSelection.value=t.reserveSelection),e.$ready&&(e.store.updateColumns(),e.store.scheduleLayout())},removeColumn(l,t,a){const n=(0,o.SU)(l._columns)||[];if(a)a.children.splice(a.children.findIndex((e=>e.id===t.id)),1),0===a.children.length&&delete a.children,l._columns.value=d(n,a);else{const e=n.indexOf(t);e>-1&&(n.splice(e,1),l._columns.value=n)}e.$ready&&(e.store.updateColumns(),e.store.scheduleLayout())},sort(l,t){const{prop:a,order:n,init:r}=t;if(a){const t=(0,o.SU)(l.columns).find((e=>e.property===a));t&&(t.order=n,e.store.updateSort(t,a,n),e.store.commit("changeSortCondition",{init:r}))}},changeSortCondition(l,t){const{sortingColumn:a,sortProp:n,sortOrder:r}=l;null===(0,o.SU)(r)&&(l.sortingColumn.value=null,l.sortProp.value=null);e.store.execQuery({filter:!0}),t&&(t.silent||t.init)||e.emit("sort-change",{column:(0,o.SU)(a),prop:(0,o.SU)(n),order:(0,o.SU)(r)}),e.store.updateTableScrollY()},filterChange(l,t){const{column:a,values:n,silent:o}=t,r=e.store.updateFilters(a,n);e.store.execQuery(),o||e.emit("filter-change",r),e.store.updateTableScrollY()},toggleAllSelection(){e.store.toggleAllSelection()},rowSelectedChanged(l,t){e.store.toggleRowSelection(t),e.store.updateAllSelected()},setHoverRow(e,l){e.hoverRow.value=l},setCurrentRow(l,t){e.store.updateCurrentRow(t)}},commit:function(l,...t){const a=e.store.mutations;if(!a[l])throw new Error(`Action not found: ${l}`);a[l].apply(e,[e.store.states].concat(t))},updateTableScrollY:function(){(0,a.Y3)((()=>e.layout.updateScrollY.apply(e.layout)))}}}const p={rowKey:"rowKey",defaultExpandAll:"defaultExpandAll",selectOnIndeterminate:"selectOnIndeterminate",indent:"indent",lazy:"lazy",data:"data","treeProps.hasChildren":{key:"lazyColumnIdentifier",default:"hasChildren"},"treeProps.children":{key:"childrenColumnName",default:"children"}};function f(e,l){if(!e)throw new Error("Table is required.");const t=h();return t.toggleAllSelection=(0,n.Z)(t._toggleAllSelection,10),Object.keys(p).forEach((e=>{g(y(l,e),e,t)})),function(e,l){Object.keys(p).forEach((t=>{(0,a.YP)((()=>y(l,t)),(l=>{g(l,t,e)}))}))}(t,l),t}function g(e,l,t){let a=e,n=p[l];"object"==typeof p[l]&&(n=n.key,a=a||p[l].default),t.states[n].value=a}function y(e,l){if(l.includes(".")){const t=l.split(".");let a=e;return t.forEach((e=>{a=a[e]})),a}return e[l]}}}]);